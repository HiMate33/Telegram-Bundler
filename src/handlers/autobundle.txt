const axios = require("axios");
const { User } = require("../models/userModel");

// Fetch token details from CoinGecko by mint address
async function fetchTokenDetails(address) {
  try {
    const url = `https://api.coingecko.com/api/v3/coins/solana/contract/${address}`;
    const res = await axios.get(url);
    const data = res.data;

    return {
      name: data.name,
      symbol: data.symbol.toUpperCase(),
      price: data.market_data.current_price.usd,
      marketCap: data.market_data.market_cap.usd,
      liquidity: data.liquidity_score || 0, // CoinGecko may not provide liquidity, so fallback to 0
      address,
    };
  } catch (err) {
    console.error("CoinGecko error:", err.message);
    return {
      name: "Not found",
      symbol: "-",
      price: 0,
      marketCap: 0,
      address,
    };
  }
}

const tempInputMap = {}; // temp memory for user input flow

module.exports = {
  handleAutoBundleStart: async (bot, callbackQuery) => {
    const chatId = callbackQuery.message.chat.id;
    const telegramId = callbackQuery.from.id;

    tempInputMap[telegramId] = { step: "awaiting_token_address" };

    await bot.sendMessage(chatId, "üîç Please enter the *token address* you want to bundle-buy:", {
      parse_mode: "Markdown",
    });
  },

  handleUserReply: async (bot, msg) => {
    const telegramId = msg.from.id;
    const chatId = msg.chat.id;
    const state = tempInputMap[telegramId];

    if (!state) return;

    // Step 1: Token Address
    if (state.step === "awaiting_token_address") {
      const tokenAddress = msg.text.trim();
      const details = await fetchTokenDetails(tokenAddress);

      tempInputMap[telegramId] = {
        step: "awaiting_buy_option",
        token: details,
      };

      await bot.sendMessage(
        chatId,
        `üßæ *Token Details:*\n\n` +
        `‚Ä¢ Name: ${details.name}\n` +
        `‚Ä¢ Symbol: ${details.symbol}\n` +
        `‚Ä¢ Market Cap: $${details.marketCap.toLocaleString()}\n` +
          `‚Ä¢ Price: $${details.price}\n` +
        `‚Ä¢ Address: $${details.address.toLocaleString()}`,
        {
          parse_mode: "Markdown",
          reply_markup: {
            inline_keyboard: [
              [
                { text: "üü¢ Buy Now", callback_data: "bundle_buy_now" },
                { text: "‚è∞ Buy Later", callback_data: "bundle_buy_later" },
              ],
              [
                { text: "üí∞ Buy on Condition", callback_data: "bundle_buy_on_condition" }
              ]
            ],
          },
        }
      );
    }

    // Step 2: Amount to buy
    else if (state.step === "awaiting_amount") {
      const amount = parseFloat(msg.text.trim());
      if (isNaN(amount) || amount <= 0) {
        return bot.sendMessage(chatId, "‚ùå Please enter a valid amount (positive number).");
      }

      tempInputMap[telegramId].amount = amount;
      tempInputMap[telegramId].step = "awaiting_confirm";

      await bot.sendMessage(
        chatId,
        `‚úÖ Ready to execute *${state.buyType}*:\n\n` +
        `Token: ${state.token.name} (${state.token.symbol})\n` +
        `Amount per wallet: ${amount} SOL\n\n` +
        `Press *Confirm* to execute.`,
        {
          parse_mode: "Markdown",
          reply_markup: {
            inline_keyboard: [[{ text: "‚úÖ Confirm Buy", callback_data: "bundle_confirm_buy" }]],
          },
        }
      );
    }

    // Step 3: Buy on condition (enter condition price)
    else if (state.step === "awaiting_condition_price") {
      const price = parseFloat(msg.text.trim());
      if (isNaN(price) || price <= 0) {
        return bot.sendMessage(chatId, "‚ùå Please enter a valid price.");
      }

      tempInputMap[telegramId].conditionPrice = price;
      tempInputMap[telegramId].step = "awaiting_amount";

      return bot.sendMessage(chatId, "üí∏ Now enter the *amount* (in SOL) each wallet should buy:");
    }
  },

  handleAutoBundleActions: async (bot, callbackQuery) => {
    const telegramId = callbackQuery.from.id;
    const chatId = callbackQuery.message.chat.id;
    const action = callbackQuery.data;

    const state = tempInputMap[telegramId];
    if (!state || !state.token) return;

    // Step: Choose type of buy
    if (action === "bundle_buy_now") {
      state.buyType = "Buy Now";
      state.step = "awaiting_amount";

      return bot.sendMessage(chatId, "üí∏ Enter the *amount (in SOL)* each bundled wallet should buy:");
    }

    if (action === "bundle_buy_later") {
      state.buyType = "Buy Later";
      state.step = "awaiting_amount";

      return bot.sendMessage(chatId, "‚è∞ Enter the *amount (in SOL)* each bundled wallet should buy:");
    }

    if (action === "bundle_buy_on_condition") {
      state.buyType = "Buy on Condition";
      state.step = "awaiting_condition_price";

      return bot.sendMessage(chatId, "üìâ Enter the *price (in SOL)* the token should fall to before buying:");
    }

    // Confirm buy
    if (action === "bundle_confirm_buy") {
      const user = await User.findOne({ telegram_id: telegramId });

      if (!user || !user.bundled_wallets || user.bundled_wallets.length === 0) {
        return bot.sendMessage(chatId, "‚ö†Ô∏è You have no bundled wallets set.");
      }

      const { token, amount, conditionPrice, buyType } = state;

      // TODO: Trigger actual buy logic here
      await bot.sendMessage(chatId, `üöÄ Executing *${buyType}* for ${token.symbol} with ${user.bundled_wallets.length} wallets...`, {
        parse_mode: "Markdown",
      });

      for (let wallet of user.bundled_wallets) {
        // Replace this log with actual transaction signing/sending logic
        console.log(`Sending buy txn for ${wallet.publicKey} -> ${amount} SOL of ${token.address}`);
      }

      delete tempInputMap[telegramId];
    }
  },
};
