const axios = require("axios");
const { User } = require("../models/userModel");

const BIRDEYE_API_KEY = "3b1ddc50c3c34b9bbfc4fa019627c681";
const headers = { "x-api-key": BIRDEYE_API_KEY };

let tokenCache = { tokens: [], timestamp: 0 };

async function fetchAllTokens() {
  const now = Date.now();
  if (tokenCache.tokens.length && now - tokenCache.timestamp < 30000) {
    return tokenCache.tokens;
  }
  let allTokens = [];
  let scrollId = null;
  let tries = 0;
  const maxTries = 10;
  do {
    const params = {
      limit: '5000',
      sort_by: 'liquidity',
      sort_type: 'desc'
    };
    if (scrollId) params.scroll_id = scrollId;
    const options = {
      method: 'GET',
      url: 'https://public-api.birdeye.so/defi/v3/token/list/scroll',
      params,
      headers: {
        accept: 'application/json',
        'x-chain': 'solana',
        'x-api-key': BIRDEYE_API_KEY
      }
    };
    const res = await axios.request(options);
    allTokens = allTokens.concat(res.data.data.items);
    scrollId = res.data.data.next_scroll_id;
    tries++;
    if (!scrollId) break;
  } while (tries < maxTries);
  tokenCache = { tokens: allTokens, timestamp: now };
  return allTokens;
}

async function fetchTokenData(mint) {
  try {
    const tokens = await fetchAllTokens();
    const found = tokens.find(t => t.address === mint);
    if (found) {
      return {
        symbol: found.symbol,
        name: found.name,
        price: found.price,
        volume: found.volume_24h_usd,
        marketCap: found.market_cap
      };
    }
    return null;
  } catch (err) {
    console.error("Birdeye error:", err.message);
    return null;
  }
}

async function handleVolumeMenu(bot, callbackQuery) {
  const chatId = callbackQuery.message.chat.id;
  const telegramId = callbackQuery.from.id;

  const user = await User.findOne({ telegram_id: telegramId });
  const enabled = user?.volume_tracking?.enabled !== false;

  const msg = `üìä *Volume Tracker Menu*\n\nAlerts: *${enabled ? "ON" : "OFF"}*\nSelect an action below:`;

  const buttons = [
    [
      { text: "‚ûï Add Token", callback_data: "volume_add" },
      { text: "‚öôÔ∏è Set Condition", callback_data: "volume_condition" }
    ],
    [
      { text: "üìÑ My Tokens", callback_data: "volume_list" },
      { text: "‚ùå Remove Token", callback_data: "volume_remove" }
    ],
    [
      { text: enabled ? "üîï Disable Alerts" : "üîî Enable Alerts", callback_data: "volume_alerts_toggle" }
    ]
  ];

  await bot.sendMessage(chatId, msg, {
    parse_mode: "Markdown",
    reply_markup: { inline_keyboard: buttons }
  });

  await bot.answerCallbackQuery(callbackQuery.id);
}

async function promptAddToken(bot, callbackQuery) {
  const chatId = callbackQuery.message.chat.id;
  const telegramId = callbackQuery.from.id;

  await User.findOneAndUpdate(
    { telegram_id: telegramId },
    { temp_input: { type: "add_token" } }
  );

  await bot.sendMessage(chatId, "üÜï Please enter the token mint address you want to track.");
  await bot.answerCallbackQuery(callbackQuery.id);
}

async function promptSetCondition(bot, callbackQuery) {
  const chatId = callbackQuery.message.chat.id;
  const telegramId = callbackQuery.from.id;

  await User.findOneAndUpdate(
    { telegram_id: telegramId },
    { temp_input: { type: "set_condition" } }
  );

  await bot.sendMessage(chatId, "‚öôÔ∏è Please enter in the format:\n\n`mint volume% price% interval_minutes`\n\nExample:\n`6eNUb... 50 10 5`", {
    parse_mode: "Markdown"
  });

  await bot.answerCallbackQuery(callbackQuery.id);
}

async function promptRemoveToken(bot, callbackQuery) {
  const chatId = callbackQuery.message.chat.id;
  const telegramId = callbackQuery.from.id;

  await User.findOneAndUpdate(
    { telegram_id: telegramId },
    { temp_input: { type: "remove_token" } }
  );

  await bot.sendMessage(chatId, "‚ùå Please enter the mint address of the token you want to remove.");
  await bot.answerCallbackQuery(callbackQuery.id);
}
async function handleMyTokens(bot, callbackQuery) {
  const chatId = callbackQuery.message.chat.id;
  const telegramId = callbackQuery.from.id;
  const user = await User.findOne({ telegram_id: telegramId });

  const tokens = user?.volume_tracking?.tokens || [];

  if (!tokens.length) {
    return bot.sendMessage(chatId, "üòï You're not tracking any tokens.");
  }

  let message = `üìä *Tracked Tokens*:\n`;

  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    const data = await fetchTokenData(t.mint);

    if (data) {
      message += `\n${i + 1}. \`${t.mint}\`\n`;
      message += `  üè∑Ô∏è *${data.name}* (${data.symbol})\n`;
      message += `  üí≤ Price: $${data.price?.toLocaleString(undefined, {maximumFractionDigits: 6})}\n`;
      message += `  üìä Volume(24h): $${data.volume?.toLocaleString(undefined, {maximumFractionDigits: 2})}\n`;
      message += `  üè¶ Market Cap: $${data.marketCap?.toLocaleString(undefined, {maximumFractionDigits: 2})}\n`;
    } else {
      message += `\n${i + 1}. \`${t.mint}\`\n  ‚ö†Ô∏è Token data not found\n`;
    }
    message += `  üîÅ Every ${t.interval || 5}min | üìà ${t.priceThresh || 10}% | üìä ${t.volThresh || 50}%\n`;
  }

  await bot.sendMessage(chatId, message, { parse_mode: "Markdown" });
  await bot.answerCallbackQuery(callbackQuery.id);
}

async function toggleAlerts(bot, callbackQuery) {
  const telegramId = callbackQuery.from.id;
  const chatId = callbackQuery.message.chat.id;
  const user = await User.findOne({ telegram_id: telegramId });

  user.volume_tracking.enabled = !user.volume_tracking.enabled;
  await user.save();

  await bot.sendMessage(chatId, `üîî Alerts are now *${user.volume_tracking.enabled ? "ON" : "OFF"}*`, {
    parse_mode: "Markdown"
  });

  return handleVolumeMenu(bot, callbackQuery);
}

async function handleUserReply(bot, msg) {
  const telegramId = msg.from.id;
  const chatId = msg.chat.id;
  const text = msg.text.trim();

  const user = await User.findOne({ telegram_id: telegramId });
  const state = user?.temp_input;

  if (!state) return;

  if (state.type === "add_token") {
    const mint = text;

    const exists = user.volume_tracking.tokens?.some(t => t.mint === mint);
    if (exists) {
      user.temp_input = null;
      await user.save();
      return bot.sendMessage(chatId, "‚ö†Ô∏è Token already being tracked.");
    }

    user.volume_tracking.tokens.push({ mint });
    user.temp_input = null;
    await user.save();

    return bot.sendMessage(chatId, `‚úÖ Now tracking token: ${mint}`);
  }

  if (state.type === "set_condition") {
    const [mint, vol, price, interval] = text.split(/\s+/);

    const token = user.volume_tracking.tokens.find(t => t.mint === mint);
    if (!token) {
      user.temp_input = null;
      await user.save();
      return bot.sendMessage(chatId, "‚ùå Token not found. Please add it first.");
    }

    token.volThresh = parseFloat(vol);
    token.priceThresh = parseFloat(price);
    token.interval = parseInt(interval);
    user.temp_input = null;
    await user.save();

    return bot.sendMessage(chatId, `‚öôÔ∏è Conditions updated for ${mint}`);
  }

  if (state.type === "remove_token") {
    const mint = text;
    const initialLength = user.volume_tracking.tokens.length;

    user.volume_tracking.tokens = user.volume_tracking.tokens.filter(t => t.mint !== mint);
    user.temp_input = null;
    await user.save();

    if (user.volume_tracking.tokens.length === initialLength) {
      return bot.sendMessage(chatId, "‚ö†Ô∏è Token not found or already removed.");
    }

    return bot.sendMessage(chatId, `‚ùå Token removed: ${mint}`);
  }
}
async function volumeMonitor(bot) {
  const users = await User.find({ "volume_tracking.enabled": true });

  for (const user of users) {
    for (const token of user.volume_tracking.tokens) {
      const { mint, volThresh = 50, priceThresh = 10, lastSnapshot = {} } = token;

      const data = await fetchTokenData(mint);
      if (!data) continue;

      const { price, volume } = data;
      const oldPrice = lastSnapshot.price || price;
      const oldVol = lastSnapshot.volume || volume;

      const priceChange = ((price - oldPrice) / oldPrice) * 100;
      const volChange = ((volume - oldVol) / oldVol) * 100;

      if (Math.abs(priceChange) >= priceThresh || Math.abs(volChange) >= volThresh) {
        await bot.sendMessage(user.chat_id, `üö® *Alert for ${mint}*\n` +
          `Price: ${oldPrice.toFixed(6)} ‚Üí ${price.toFixed(6)} (${priceChange.toFixed(2)}%)\n` +
          `Volume: ${oldVol.toFixed(2)} ‚Üí ${volume.toFixed(2)} (${volChange.toFixed(2)}%)`, {
          parse_mode: "Markdown"
        });
      }

      token.lastSnapshot = { price, volume };
    }

    await user.save();
  }
}

module.exports = {
  handleVolumeMenu,
  promptAddToken,
  promptSetCondition,
  promptRemoveToken,
  handleMyTokens,
  toggleAlerts,
  handleUserReply,
  volumeMonitor
};


