equire('dotenv').config();
const express = require('express');
const bs58 = require('bs58');
const fetch = require('node-fetch');
const { Connection, Keypair, PublicKey, LAMPORTS_PER_SOL } = require('@solana/web3.js');
const { Jupiter } = require('@jup-ag/core');

const app = express();
app.use(express.json());

const RPC_ENDPOINT = 'https://api.mainnet-beta.solana.com'; // Use devnet if testing
const connection = new Connection(RPC_ENDPOINT, 'confirmed');

// Load wallet
const wallet = Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY));

app.post('/buy', async (req, res) => {
  const { tokenAddress, solAmount } = req.body;

  if (!tokenAddress  !solAmount) {
    return res.status(400).json({ error: 'tokenAddress and solAmount are required.' });
  }

  try {
    const jupiter = await Jupiter.load({
      connection,
      cluster: 'mainnet-beta',
      user: wallet,
    });

    const inputMint = new PublicKey("So11111111111111111111111111111111111111112"); // SOL wrapped token
    const outputMint = new PublicKey(tokenAddress);
    const amountInLamports = solAmount * LAMPORTS_PER_SOL;

    const { routesInfos } = await jupiter.computeRoutes({
      inputMint,
      outputMint,
      amount: amountInLamports,
      slippageBps: 50, // 0.5% slippage
    });

    if (!routesInfos  routesInfos.length === 0) {
      return res.status(404).json({ error: 'No routes found for this token.' });
    }

    const bestRoute = routesInfos[0];

    const { execute } = await jupiter.exchange({ routeInfo: bestRoute });
    const tx = await execute();

    return res.json({
      message: 'Swap executed successfully.',
      transactionId: tx.txid,
    });

  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Swap failed.', details: err.message });
  }
});

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});





===============
===============
===============








const fetch = require("node-fetch");
const readline = require("readline");
const {
Â  PublicKey,
Â  Connection,
Â  Transaction,
Â  Keypair,
Â  VersionedTransaction,
} = require("@solana/web3.js");

// === CONFIGURATION ===
const secretKey = Uint8Array.from([
Â  108, 21, 143, 211, 58, 75, 126, 232, 129, 80, 235, 79, 54, 219, 65, 240, 219,
Â  8, 209, 149, 36, 201, 209, 222, 99, 137, 247, 40, 40, 192, 176, 101, 121, 143,
Â  187, 138, 212, 169, 248, 219, 101, 113, 91, 6, 7, 189, 200, 222, 217, 141, 0,
Â  15, 213, 247, 164, 43, 131, 238, 201, 243, 31, 157, 146, 70,
]);

const keypair = Keypair.fromSecretKey(secretKey);
const userPublicKey = keypair.publicKey;

const inputMint = "So11111111111111111111111111111111111111112"; // SOL
const outputMint = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"; // USDC
const slippageBps = 50; // 0.5%

const connection = new Connection(
Â  "https://api.mainnet-beta.solana.com",
Â  "confirmed"
);

// === FUNCTIONS ===

async function getSolRequiredForUSDC(usdcAmount) {
Â  const url = https://lite-api.jup.ag/price/v2?ids=${outputMint}&vsToken=${inputMint};
Â  const res = await fetch(url);
Â  const data = await res.json();

Â  const usdcVsSolPrice = parseFloat(data.data[outputMint].price);
Â  const requiredSol = usdcAmount * usdcVsSolPrice;
Â  const lamports = Math.floor(requiredSol * 1e9);

Â  console.log(
Â Â Â  ðŸ” ${usdcAmount} USDC â‰ˆ ${requiredSol.toFixed(
Â Â Â Â Â  6
Â Â Â  )} SOL (${lamports} lamports)
Â  );
Â  return lamports;
}

async function getQuote(lamports) {
Â  const url = https://lite-api.jup.ag/swap/v1/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=${lamports}&slippageBps=${slippageBps}&restrictIntermediateTokens=true;
Â  console.log("ðŸ“¡ Fetching quote from Jupiter...");

Â  const res = await fetch(url);
Â  if (!res.ok) throw new Error(Quote failed: ${res.status} ${res.statusText});
Â  const data = await res.json();

Â  if (!data !data.routePlan data.routePlan.length === 0) {
Â Â Â  throw new Error("No valid route found.");
Â  }

Â  console.log("âœ… Quote received.");
Â  return data;
}

async function buildSwapTransaction(quoteResponse) {
Â  console.log("ðŸ§± Building transaction...");

Â  const res = await fetch("https://lite-api.jup.ag/swap/v1/swap", {
Â Â Â  method: "POST",
Â Â Â  headers: { "Content-Type": "application/json" },
Â Â Â  body: JSON.stringify({
Â Â Â Â Â  quoteResponse,
Â Â Â Â Â  userPublicKey: userPublicKey.toBase58(),
Â Â Â Â Â  dynamicComputeUnitLimit: true,
Â Â Â Â Â  dynamicSlippage: true,
Â Â Â Â Â  prioritizationFeeLamports: {
Â Â Â Â Â Â Â  priorityLevelWithMaxLamports: {
Â Â Â Â Â Â Â Â Â  maxLamports: 1000000,
Â Â Â Â Â Â Â Â Â  priorityLevel: "veryHigh",
Â Â Â Â Â Â Â  },
Â Â Â Â Â  },
Â Â Â  }),
Â  });

Â  if (!res.ok) {
Â Â Â  const errText = await res.text();
Â Â Â  throw new Error(
Â Â Â Â Â  Swap API failed: ${res.status} ${res.statusText} - ${errText}
Â Â Â  );
Â  }

Â  const swapResponse = await res.json();
Â  if (!swapResponse.swapTransaction)
Â Â Â  throw new Error("No transaction returned.");
Â  console.log("âœ… Swap transaction built.");
Â  return swapResponse.swapTransaction;
}

async function sendTransaction(base64Tx) {
Â  console.log("ðŸš€ Sending transaction to Solana...");

Â  const txBuffer = Buffer.from(base64Tx, "base64");
Â  const versionedTx = VersionedTransaction.deserialize(txBuffer);

Â  versionedTx.sign([keypair]);
Â  const rawTx = versionedTx.serialize();

Â  const signature = await connection.sendRawTransaction(rawTx, {
Â Â Â  maxRetries: 2,
Â Â Â  skipPreflight: true,
Â  });

Â  console.log("âœ… Sent! Tx Signature:", signature);
Â  const confirmation = await connection.confirmTransaction(
Â Â Â  { signature },
Â Â Â  "finalized"
Â  );

Â  if (confirmation.value.err) {
Â Â Â  throw new Error(
Â Â Â Â Â  Transaction failed: ${JSON.stringify(
Â Â Â Â Â Â Â  confirmation.value.err
Â Â Â Â Â  )}\nhttps://solscan.io/tx/${signature}
Â Â Â  );
Â  }

Â  console.log(ðŸŽ‰ Confirmed: https://solscan.io/tx/${signature});
}

async function main() {
Â  const rl = readline.createInterface({
Â Â Â  input: process.stdin,
Â Â Â  output: process.stdout,
Â  });

Â  rl.question("ðŸ’µ Enter USDC amount to swap from SOL: ", async (input) => {
Â Â Â  rl.close();  




