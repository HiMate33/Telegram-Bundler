You said:
==>> I am working n a project telegram token creator . .

bot / start.js 

const { User } = require("../models/userModel");

module.exports = (bot) => {
  bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id;
    const telegramId = Number(msg.from.id); 

    const userData = {
      telegram_id: telegramId,
      username: msg.from.username,
      first_name: msg.from.first_name,
      last_name: msg.from.last_name,
      is_bot: msg.from.is_bot,
      language_code: msg.from.language_code,
      chat_id: chatId,
    };

    let user = await User.findOne({ telegram_id: telegramId });

    if (!user) {
      try {
        user = await User.create(userData);
        console.log("✅ New user saved:", userData.username || userData.first_name);
      } catch (error) {
        console.error("❌ Failed to save user:", error);
        return bot.sendMessage(
          chatId,
          "An error occurred while saving your data. Please try again."
        );
      }
    }

    const currentProvider = user.rpc_provider?.name || "Not Set";

    const welcomeMsg = 🤖 *GhostBundler* 🔗

Automate token creation and bundle-buy on *Pump.fun* 🚀

🎯 Features:
- 📦 Bundle multiple wallets
- 🛒 Auto-buy fresh token launches
- 🆕 Create and launch your own tokens
- 🌐 Network-wide bundling tools

*🌐 Current Network:* \${currentProvider}\

Tap a button below to begin bundling your strategy!;

    const buttons = [
      [{ text: "⚙️ Auto Bundle", callback_data: "auto_bundle" }],
      [{ text: "👛 Set Main Wallet", callback_data: "main_wallet" }, { text: "📦 Set Bundled Wallets", callback_data: "bundled_wallets" }],
      [{ text: "🆕 Create Token", callback_data: "create_token" }, { text: "🛒 Buy Tokens", callback_data: "buy_tokens" }],
      [{ text: "🌐 Set Newtork Provider (RPC)", callback_data: "bundled_network" }],
      [{ text: "👤 Account Info", callback_data: "account_info" }],
    ];

    bot.sendMessage(chatId, welcomeMsg, {
      parse_mode: "Markdown",
      reply_markup: {
        inline_keyboard: buttons,
      },
    });
  });
};  

==>>  handlers  / index.js   (to handle callbackqueries only)

const connectWalletHandler = require("./walletConnect");
const networkHandler = require("./networkHandler");
const rpcProviders = require("../config/rpcProviders");
const { User } = require("../models/userModel");
const bundleHandler = require("./walletBundleHandler");
const handleBundleCreate = require("./bundleCreate");
const handleBundleImport = require("./bundleImport");
const accountInfoHandler = require("./accountInfo");
const handleCreateToken = require("./createToken");



module.exports = (bot) => {

   bot.onText(/\/create_token/, (msg) => handleCreateToken(bot, msg));
  bot.onText(/\/main_wallet/, (msg) => connectWalletHandler(bot, msg));
  bot.onText(/\/bundled_wallets/, (msg) => bundleHandler(bot, msg));
  bot.onText(/\/bundled_network/, (msg) => networkHandler(bot, msg));
  bot.onText(/\/account_info/, (msg) => accountInfoHandler(bot, msg));

  bot.on("callback_query", async (callbackQuery) => {
    const chatId = callbackQuery.message.chat.id;
    const action = callbackQuery.data;
    const telegramId = callbackQuery.from.id;

    // Handle wallet actions
    if (
      action === "main_wallet" ||
      action === "create_wallet" ||
      action === "import_wallet"
    ) {
      return connectWalletHandler(bot, callbackQuery);
    }
    if (action === "bundled_wallets") {
  return bundleHandler(bot, callbackQuery);
}


    // ✅ Handle "bundled_network" action
    if (action === "bundled_network") {
      return networkHandler(bot, callbackQuery);
    }
if (action === "account_info") {
  return accountInfoHandler(bot, callbackQuery);
}

    // Inside bot.on("callback_query", async (callbackQuery) => {
if (action.startsWith("bundle_create_")) {
  const count = parseInt(action.split("_")[2], 10);
  return handleBundleCreate(bot, telegramId, chatId, count);
}
if (action === "create_token") {
 return handleCreateToken(bot, callbackQuery)
}

/*
if (action === "create_token") {
  return handleCreateToken(bot, callbackQuery.message);
}
  */

if (action.startsWith("bundle_import_")) {
  const count = parseInt(action.split("_")[2], 10);
  return handleBundleImport(bot, telegramId, chatId, count);
}


    // ✅ Handle selecting an RPC provider
    if (action.startsWith("rpc_")) {
      const index = parseInt(action.split("_")[1], 10);
      const selectedRPC = rpcProviders[index];

      await User.findOneAndUpdate(
        { telegram_id: telegramId },
        { rpc_provider: selectedRPC }
      );

      await bot.sendMessage(chatId, ✅ RPC Provider set to *${selectedRPC.name}*, {
        parse_mode: "Markdown",
      });

      return bot.answerCallbackQuery(callbackQuery.id);
    }

    bot.answerCallbackQuery(callbackQuery.id);
  });

 
};


==>>   models / userModel.js 

const mongoose = require("mongoose");
const dotenv = require("dotenv");

dotenv.config();

const userSchema = new mongoose.Schema({
  telegram_id: { type: Number, required: true, unique: true },
  username: { type: String },
  first_name: { type: String },
  last_name: { type: String },
  is_bot: { type: Boolean, default: false },
  language_code: { type: String },
  chat_id: { type: Number },

  wallet: {
    publicKey: { type: String },
    privateKey: { type: String },
  },


  bundled_wallets: [
  {
    publicKey: { type: String },
    privateKey: { type: String },
  },
],
bundled_wallet_buy_amount: [Number],



  
   
  rpc_provider: {
  name: { type: String, default: "Mainnet Beta" },
  url: { type: String, default: "https://api.mainnet-beta.solana.com" },
},

  // OTHER MODELS
});

const User = mongoose.model("User", userSchema);

module.exports = { User };


==>>   I need createToken.js 
to handle the token creation functionality  using metaplex.. 


==> here is an example of token creation using metaplex from their docs..  
- use the private key of user stored in the database to sign the transaction.  
-  let user be able to enter .  name, symbol,  amount of token to mint,  decimal, upload image,  then review what he selected.  then see a create token button to create token.  


const {
  createFungible,
  mplTokenMetadata,
} = require("@metaplex-foundation/mpl-token-metadata");
const {
  createTokenIfMissing,
  findAssociatedTokenPda,
  getSplAssociatedTokenProgramId,
  mintTokensTo,
} = require("@metaplex-foundation/mpl-toolbox");
const {
  createGenericFile,
  percentAmount,
  signerIdentity,
  sol,
  createSignerFromKeypair,
  KeypairSigner,
  generateSigner,
} = require("@metaplex-foundation/umi");
const { createUmi } = require("@metaplex-foundation/umi-bundle-defaults");
const { irysUploader } = require("@metaplex-foundation/umi-uploader-irys");
const { base58 } = require("@metaplex-foundation/umi/serializers");
const fs = require("fs");
const bs58 = require("bs58");

require("dotenv").config;

const PRIVATE_KEY_STRING = process.env.SOLANA_PRIVATE_KEY;

const createAndMintTokens = async () => {
  const umi = createUmi(
    "https://devnet-aura.metaplex.com/af9b1c0f-96b6-4f65-bfb3-118b3cd3b538"
  )
    .use(mplTokenMetadata())
    .use(irysUploader());

  const secretKeyBytes = bs58.decode(PRIVATE_KEY_STRING);
  const keypair = umi.eddsa.createKeypairFromSecretKey(secretKeyBytes);
  const signer = createSignerFromKeypair(umi, keypair);
  //const signer = generateSigner(umi);
  umi.use(signerIdentity(signer));

  const imageBuffer = fs.readFileSync("./bfr.jpg");
  const umiImageFile = createGenericFile(imageBuffer, "image.png", {
    tags: [{ name: "Content-Type", value: "image/png" }],
  });

  console.log("Uploading image to Arweave via Irys...");
  const imageUri = await umi.uploader.upload([umiImageFile]);
  console.log("Image URI:", imageUri[0]);

  const metadata = {
    name: "Zeus Token",
    symbol: "$Zeus",
    description: "Zeus token is here for the metavers token",
    image: imageUri[0],
  };

  console.log("Uploading metadata to Arweave...");
  const metadataUri = await umi.uploader.uploadJson(metadata);
  console.log("Metadata URI:", metadataUri);

  const mintKepair = umi.eddsa.generateKeypair();
  const mintSigner = createSignerFromKeypair(umi, mintKepair);

  const createFungibleIx = createFungible(umi, {
    mint: mintSigner,
    name: metadata.name,
    symbol: metadata.symbol,
    uri: metadataUri,
    sellerFeeBasisPoints: percentAmount(0),
    decimals: 9,
  });

  const createTokenIx = createTokenIfMissing(umi, {
    mint: mintSigner.publicKey,
    owner: umi.identity.publicKey,
    ataProgram: getSplAssociatedTokenProgramId(umi),
  });

  const mintTokensIx = mintTokensTo(umi, {
    mint: mintSigner.publicKey,
    token: findAssociatedTokenPda(umi, {
      mint: mintSigner.publicKey,
      owner: umi.identity.publicKey,
    }),
    amount: BigInt(100_000_000) * BigInt(10 ** 9),

    //amount: BigInt(1000),
  });

  console.log("Sending transaction...");
  const tx = await createFungibleIx
    .add(createTokenIx)
    .add(mintTokensIx)
    .sendAndConfirm(umi);

  const signature = base58.deserialize(tx.signature)[0];
  console.log("\n✅ Transaction Complete");
  console.log(
    🔗 View Transaction: https://explorer.solana.com/tx/${signature}?cluster=devnet
  );
  console.log(
    🔗 View Token Mint: https://explorer.solana.com/address/${mintSigner.publicKey}?cluster=devnet
  );
};

createAndMintTokens();  

=> above is a script from metaplex to create token.  use it as guide on the functionality in the handler/ createToken.js
